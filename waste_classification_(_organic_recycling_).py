# -*- coding: utf-8 -*-
"""Waste Classification ( Organic / Recycling  )

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_AfEYQQEZjX7HoosUJ6JgHLKeaTmhWpo
"""

import streamlit as st
import torch
import torch.nn as nn
from torchvision import models, transforms as T
from PIL import Image
import pandas as pd
import os

# =====================================
# CONFIG
# =====================================
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
CLASS_NAMES = ["Organic (O)", "Recycling (R)"]

# Path to trained weights (optional)
MODEL_PATHS = {
    "ResNet50": "models/ResNet50_best.pth",
    "MobileNetV2": "models/MobileNetV2_best.pth",
    "EfficientNetB0": "models/EfficientNetB0_best.pth",
}

# =====================================
# MODEL LOADING
# =====================================
@st.cache_resource
def load_model(name):
    if name == "ResNet50":
        model = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V2)
        model.fc = nn.Linear(model.fc.in_features, 2)
    elif name == "MobileNetV2":
        model = models.mobilenet_v2(weights=models.MobileNet_V2_Weights.IMAGENET1K_V1)
        model.classifier[1] = nn.Linear(model.classifier[1].in_features, 2)
    elif name == "EfficientNetB0":
        model = models.efficientnet_b0(weights=models.EfficientNet_B0_Weights.IMAGENET1K_V1)
        model.classifier[1] = nn.Linear(model.classifier[1].in_features, 2)
    else:
        raise ValueError("Unknown model!")

    # Try loading trained weights
    if os.path.exists(MODEL_PATHS[name]):
        st.success(f"✅ Loaded trained weights for {name}")
        model.load_state_dict(torch.load(MODEL_PATHS[name], map_location=DEVICE))
    else:
        st.warning(f"⚠️ No trained weights found for {name}, using ImageNet pretrained.")

    model.to(DEVICE).eval()
    return model

# =====================================
# TRANSFORMS
# =====================================
test_tf = T.Compose([
    T.Resize((224,224)),
    T.ToTensor(),
    T.Normalize([0.485,0.456,0.406],[0.229,0.224,0.225]),
])

def predict(model, img):
    with torch.no_grad():
        x = test_tf(img).unsqueeze(0).to(DEVICE)
        out = torch.softmax(model(x),1)
        conf, pred = torch.max(out,1)
    return CLASS_NAMES[pred.item()], conf.item(), out.cpu().numpy()[0]

# =====================================
# STREAMLIT APP
# =====================================
st.title("♻️ Waste Classification App")
st.markdown("Upload an image and classify it as **Organic (O)** or **Recycling (R)**")

uploaded_file = st.file_uploader("Upload an image", type=["jpg","jpeg","png"])
model_choice = st.selectbox("Choose a model:", list(MODEL_PATHS.keys()))

if uploaded_file:
    img = Image.open(uploaded_file).convert("RGB")
    st.image(img, caption="Uploaded Image", use_column_width=True)

    model = load_model(model_choice)
    label, conf, probs = predict(model, img)

    st.subheader("Prediction")
    st.write(f"**{label}** with confidence **{conf:.2f}**")

    st.bar_chart(pd.DataFrame({"Confidence": probs}, index=CLASS_NAMES))

    # Compare across all models
    st.subheader("Compare Across Models")
    all_results = {}
    for mname in MODEL_PATHS.keys():
        m = load_model(mname)
        lab, cf, _ = predict(m, img)
        all_results[mname] = {"Label": lab, "Confidence": round(cf,2)}
    st.dataframe(pd.DataFrame(all_results).T)